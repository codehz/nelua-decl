##[[
cdefine 'MINIAUDIO_IMPLEMENTATION'
cinclude '"miniaudio.h"'
if ccinfo.is_linux then
  linklib 'dl'
  linklib 'pthread'
elseif ccinfo.is_windows then
  linklib 'ole32'
end
]]
## if ccinfo.is_windows then
global ma_thread: type = @pointer
global ma_mutex: type = @pointer
global ma_event: type = @pointer
global ma_semaphore: type = @pointer
## else
global __pthread_internal_list: type <cimport, nodecl, ctypedef> = @record{
  __prev: *__pthread_internal_list,
  __next: *__pthread_internal_list
}
global __pthread_list_t: type = @__pthread_internal_list
global __pthread_mutex_s: type <cimport, nodecl, ctypedef> = @record{
  __lock: cint,
  __count: cuint,
  __owner: cint,
  __nusers: cuint,
  __kind: cint,
  __spins: cshort,
  __elision: cshort,
  __list: __pthread_list_t
}
global __pthread_cond_s: type <cimport, nodecl, ctypedef> = @record{
  __unnamed1: union{
    __wseq: culonglong,
    __wseq32: record{
      __low: cuint,
      __high: cuint
    }
  },
  __unnamed2: union{
    __g1_start: culonglong,
    __g1_start32: record{
      __low: cuint,
      __high: cuint
    }
  },
  __g_refs: [2]cuint,
  __g_size: [2]cuint,
  __g1_orig_size: cuint,
  __wrefs: cuint,
  __g_signals: [2]cuint
}
global pthread_mutex_t: type <cimport, nodecl> = @union{
  __data: __pthread_mutex_s,
  __size: [40]cchar,
  __align: clong
}
global pthread_cond_t: type <cimport, nodecl> = @union{
  __data: __pthread_cond_s,
  __size: [48]cchar,
  __align: clonglong
}
global ma_thread: type = @culong
global ma_mutex: type = @pthread_mutex_t
global ma_event: type <cimport, nodecl> = @record{
  value: uint32,
  lock: pthread_mutex_t,
  cond: pthread_cond_t
}
global ma_semaphore: type <cimport, nodecl> = @record{
  value: cint,
  lock: pthread_mutex_t,
  cond: pthread_cond_t
}
## end
global ma_bool8: type = @cuchar
global ma_bool32: type = @cuint
global ma_handle: type = @pointer
global ma_ptr: type = @pointer
global ma_proc: type <cimport, nodecl> = @function()
global ma_context: type <cimport, nodecl, forwarddecl> = @record{}
global ma_device: type <cimport, nodecl, forwarddecl> = @record{}
global ma_result: type = @cint
global ma_stream_format: type <cimport, nodecl, using> = @enum(cint){
  ma_stream_format_pcm = 0
}
global ma_stream_layout: type <cimport, nodecl, using> = @enum(cint){
  ma_stream_layout_interleaved = 0,
  ma_stream_layout_deinterleaved = 1
}
global ma_dither_mode: type <cimport, nodecl, using> = @enum(cint){
  ma_dither_mode_none = 0,
  ma_dither_mode_rectangle = 1,
  ma_dither_mode_triangle = 2
}
global ma_format: type <cimport, nodecl, using> = @enum(cint){
  ma_format_unknown = 0,
  ma_format_u8 = 1,
  ma_format_s16 = 2,
  ma_format_s24 = 3,
  ma_format_s32 = 4,
  ma_format_f32 = 5,
  ma_format_count = 6
}
global ma_standard_sample_rate: type <cimport, nodecl, using> = @enum(cint){
  ma_standard_sample_rate_48000 = 48000,
  ma_standard_sample_rate_44100 = 44100,
  ma_standard_sample_rate_32000 = 32000,
  ma_standard_sample_rate_24000 = 24000,
  ma_standard_sample_rate_22050 = 22050,
  ma_standard_sample_rate_88200 = 88200,
  ma_standard_sample_rate_96000 = 96000,
  ma_standard_sample_rate_176400 = 176400,
  ma_standard_sample_rate_192000 = 192000,
  ma_standard_sample_rate_16000 = 16000,
  ma_standard_sample_rate_11025 = 11250,
  ma_standard_sample_rate_8000 = 8000,
  ma_standard_sample_rate_352800 = 352800,
  ma_standard_sample_rate_384000 = 384000,
  ma_standard_sample_rate_min = 8000,
  ma_standard_sample_rate_max = 384000,
  ma_standard_sample_rate_count = 14
}
global ma_channel_mix_mode: type <cimport, nodecl, using> = @enum(cint){
  ma_channel_mix_mode_rectangular = 0,
  ma_channel_mix_mode_simple = 1,
  ma_channel_mix_mode_custom_weights = 2,
  ma_channel_mix_mode_planar_blend = 0,
  ma_channel_mix_mode_default = 0
}
global ma_standard_channel_map: type <cimport, nodecl, using> = @enum(cint){
  ma_standard_channel_map_microsoft = 0,
  ma_standard_channel_map_alsa = 1,
  ma_standard_channel_map_rfc3551 = 2,
  ma_standard_channel_map_flac = 3,
  ma_standard_channel_map_vorbis = 4,
  ma_standard_channel_map_sound4 = 5,
  ma_standard_channel_map_sndio = 6,
  ma_standard_channel_map_webaudio = 3,
  ma_standard_channel_map_default = 0
}
global ma_performance_profile: type <cimport, nodecl, using> = @enum(cint){
  ma_performance_profile_low_latency = 0,
  ma_performance_profile_conservative = 1
}
global ma_allocation_callbacks: type <cimport, nodecl> = @record{
  pUserData: pointer,
  onMalloc: function(csize, pointer): pointer,
  onRealloc: function(pointer, csize, pointer): pointer,
  onFree: function(pointer, pointer)
}
global ma_lcg: type <cimport, nodecl> = @record{
  state: int32
}
global ma_thread_priority: type <cimport, nodecl, using> = @enum(cint){
  ma_thread_priority_idle = -5,
  ma_thread_priority_lowest = -4,
  ma_thread_priority_low = -3,
  ma_thread_priority_normal = -2,
  ma_thread_priority_high = -1,
  ma_thread_priority_highest = 0,
  ma_thread_priority_realtime = 1,
  ma_thread_priority_default = 0
}
global ma_spinlock: type = @cuchar
global function ma_version(pMajor: *uint32, pMinor: *uint32, pRevision: *uint32) <cimport, nodecl> end
global function ma_version_string(): cstring <cimport, nodecl> end
global ma_biquad_coefficient: type <cimport, nodecl> = @union{
  f32: float32,
  s32: int32
}
global ma_biquad_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  b0: float64,
  b1: float64,
  b2: float64,
  a0: float64,
  a1: float64,
  a2: float64
}
global function ma_biquad_config_init(format: ma_format, channels: uint32, b0: float64, b1: float64, b2: float64, a0: float64, a1: float64, a2: float64): ma_biquad_config <cimport, nodecl> end
global ma_biquad: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  b0: ma_biquad_coefficient,
  b1: ma_biquad_coefficient,
  b2: ma_biquad_coefficient,
  a1: ma_biquad_coefficient,
  a2: ma_biquad_coefficient,
  r1: [32]ma_biquad_coefficient,
  r2: [32]ma_biquad_coefficient
}
global function ma_biquad_init(pConfig: *ma_biquad_config, pBQ: *ma_biquad): ma_result <cimport, nodecl> end
global function ma_biquad_reinit(pConfig: *ma_biquad_config, pBQ: *ma_biquad): ma_result <cimport, nodecl> end
global function ma_biquad_process_pcm_frames(pBQ: *ma_biquad, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_biquad_get_latency(pBQ: *ma_biquad): uint32 <cimport, nodecl> end
global ma_lpf1_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  cutoffFrequency: float64,
  q: float64
}
global ma_lpf2_config: type = @ma_lpf1_config
global function ma_lpf1_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64): ma_lpf1_config <cimport, nodecl> end
global function ma_lpf2_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64, q: float64): ma_lpf2_config <cimport, nodecl> end
global ma_lpf1: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  a: ma_biquad_coefficient,
  r1: [32]ma_biquad_coefficient
}
global function ma_lpf1_init(pConfig: *ma_lpf1_config, pLPF: *ma_lpf1): ma_result <cimport, nodecl> end
global function ma_lpf1_reinit(pConfig: *ma_lpf1_config, pLPF: *ma_lpf1): ma_result <cimport, nodecl> end
global function ma_lpf1_process_pcm_frames(pLPF: *ma_lpf1, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_lpf1_get_latency(pLPF: *ma_lpf1): uint32 <cimport, nodecl> end
global ma_lpf2: type <cimport, nodecl> = @record{
  bq: ma_biquad
}
global function ma_lpf2_init(pConfig: *ma_lpf2_config, pLPF: *ma_lpf2): ma_result <cimport, nodecl> end
global function ma_lpf2_reinit(pConfig: *ma_lpf2_config, pLPF: *ma_lpf2): ma_result <cimport, nodecl> end
global function ma_lpf2_process_pcm_frames(pLPF: *ma_lpf2, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_lpf2_get_latency(pLPF: *ma_lpf2): uint32 <cimport, nodecl> end
global ma_lpf_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  cutoffFrequency: float64,
  order: uint32
}
global function ma_lpf_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64, order: uint32): ma_lpf_config <cimport, nodecl> end
global ma_lpf: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  lpf1Count: uint32,
  lpf2Count: uint32,
  lpf1: [1]ma_lpf1,
  lpf2: [4]ma_lpf2
}
global function ma_lpf_init(pConfig: *ma_lpf_config, pLPF: *ma_lpf): ma_result <cimport, nodecl> end
global function ma_lpf_reinit(pConfig: *ma_lpf_config, pLPF: *ma_lpf): ma_result <cimport, nodecl> end
global function ma_lpf_process_pcm_frames(pLPF: *ma_lpf, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_lpf_get_latency(pLPF: *ma_lpf): uint32 <cimport, nodecl> end
global ma_hpf1_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  cutoffFrequency: float64,
  q: float64
}
global ma_hpf2_config: type = @ma_hpf1_config
global function ma_hpf1_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64): ma_hpf1_config <cimport, nodecl> end
global function ma_hpf2_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64, q: float64): ma_hpf2_config <cimport, nodecl> end
global ma_hpf1: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  a: ma_biquad_coefficient,
  r1: [32]ma_biquad_coefficient
}
global function ma_hpf1_init(pConfig: *ma_hpf1_config, pHPF: *ma_hpf1): ma_result <cimport, nodecl> end
global function ma_hpf1_reinit(pConfig: *ma_hpf1_config, pHPF: *ma_hpf1): ma_result <cimport, nodecl> end
global function ma_hpf1_process_pcm_frames(pHPF: *ma_hpf1, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_hpf1_get_latency(pHPF: *ma_hpf1): uint32 <cimport, nodecl> end
global ma_hpf2: type <cimport, nodecl> = @record{
  bq: ma_biquad
}
global function ma_hpf2_init(pConfig: *ma_hpf2_config, pHPF: *ma_hpf2): ma_result <cimport, nodecl> end
global function ma_hpf2_reinit(pConfig: *ma_hpf2_config, pHPF: *ma_hpf2): ma_result <cimport, nodecl> end
global function ma_hpf2_process_pcm_frames(pHPF: *ma_hpf2, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_hpf2_get_latency(pHPF: *ma_hpf2): uint32 <cimport, nodecl> end
global ma_hpf_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  cutoffFrequency: float64,
  order: uint32
}
global function ma_hpf_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64, order: uint32): ma_hpf_config <cimport, nodecl> end
global ma_hpf: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  hpf1Count: uint32,
  hpf2Count: uint32,
  hpf1: [1]ma_hpf1,
  hpf2: [4]ma_hpf2
}
global function ma_hpf_init(pConfig: *ma_hpf_config, pHPF: *ma_hpf): ma_result <cimport, nodecl> end
global function ma_hpf_reinit(pConfig: *ma_hpf_config, pHPF: *ma_hpf): ma_result <cimport, nodecl> end
global function ma_hpf_process_pcm_frames(pHPF: *ma_hpf, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_hpf_get_latency(pHPF: *ma_hpf): uint32 <cimport, nodecl> end
global ma_bpf2_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  cutoffFrequency: float64,
  q: float64
}
global function ma_bpf2_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64, q: float64): ma_bpf2_config <cimport, nodecl> end
global ma_bpf2: type <cimport, nodecl> = @record{
  bq: ma_biquad
}
global function ma_bpf2_init(pConfig: *ma_bpf2_config, pBPF: *ma_bpf2): ma_result <cimport, nodecl> end
global function ma_bpf2_reinit(pConfig: *ma_bpf2_config, pBPF: *ma_bpf2): ma_result <cimport, nodecl> end
global function ma_bpf2_process_pcm_frames(pBPF: *ma_bpf2, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_bpf2_get_latency(pBPF: *ma_bpf2): uint32 <cimport, nodecl> end
global ma_bpf_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  cutoffFrequency: float64,
  order: uint32
}
global function ma_bpf_config_init(format: ma_format, channels: uint32, sampleRate: uint32, cutoffFrequency: float64, order: uint32): ma_bpf_config <cimport, nodecl> end
global ma_bpf: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  bpf2Count: uint32,
  bpf2: [4]ma_bpf2
}
global function ma_bpf_init(pConfig: *ma_bpf_config, pBPF: *ma_bpf): ma_result <cimport, nodecl> end
global function ma_bpf_reinit(pConfig: *ma_bpf_config, pBPF: *ma_bpf): ma_result <cimport, nodecl> end
global function ma_bpf_process_pcm_frames(pBPF: *ma_bpf, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_bpf_get_latency(pBPF: *ma_bpf): uint32 <cimport, nodecl> end
global ma_notch2_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  q: float64,
  frequency: float64
}
global function ma_notch2_config_init(format: ma_format, channels: uint32, sampleRate: uint32, q: float64, frequency: float64): ma_notch2_config <cimport, nodecl> end
global ma_notch2: type <cimport, nodecl> = @record{
  bq: ma_biquad
}
global function ma_notch2_init(pConfig: *ma_notch2_config, pFilter: *ma_notch2): ma_result <cimport, nodecl> end
global function ma_notch2_reinit(pConfig: *ma_notch2_config, pFilter: *ma_notch2): ma_result <cimport, nodecl> end
global function ma_notch2_process_pcm_frames(pFilter: *ma_notch2, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_notch2_get_latency(pFilter: *ma_notch2): uint32 <cimport, nodecl> end
global ma_peak2_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  gainDB: float64,
  q: float64,
  frequency: float64
}
global function ma_peak2_config_init(format: ma_format, channels: uint32, sampleRate: uint32, gainDB: float64, q: float64, frequency: float64): ma_peak2_config <cimport, nodecl> end
global ma_peak2: type <cimport, nodecl> = @record{
  bq: ma_biquad
}
global function ma_peak2_init(pConfig: *ma_peak2_config, pFilter: *ma_peak2): ma_result <cimport, nodecl> end
global function ma_peak2_reinit(pConfig: *ma_peak2_config, pFilter: *ma_peak2): ma_result <cimport, nodecl> end
global function ma_peak2_process_pcm_frames(pFilter: *ma_peak2, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_peak2_get_latency(pFilter: *ma_peak2): uint32 <cimport, nodecl> end
global ma_loshelf2_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  gainDB: float64,
  shelfSlope: float64,
  frequency: float64
}
global function ma_loshelf2_config_init(format: ma_format, channels: uint32, sampleRate: uint32, gainDB: float64, shelfSlope: float64, frequency: float64): ma_loshelf2_config <cimport, nodecl> end
global ma_loshelf2: type <cimport, nodecl> = @record{
  bq: ma_biquad
}
global function ma_loshelf2_init(pConfig: *ma_loshelf2_config, pFilter: *ma_loshelf2): ma_result <cimport, nodecl> end
global function ma_loshelf2_reinit(pConfig: *ma_loshelf2_config, pFilter: *ma_loshelf2): ma_result <cimport, nodecl> end
global function ma_loshelf2_process_pcm_frames(pFilter: *ma_loshelf2, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_loshelf2_get_latency(pFilter: *ma_loshelf2): uint32 <cimport, nodecl> end
global ma_hishelf2_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  gainDB: float64,
  shelfSlope: float64,
  frequency: float64
}
global function ma_hishelf2_config_init(format: ma_format, channels: uint32, sampleRate: uint32, gainDB: float64, shelfSlope: float64, frequency: float64): ma_hishelf2_config <cimport, nodecl> end
global ma_hishelf2: type <cimport, nodecl> = @record{
  bq: ma_biquad
}
global function ma_hishelf2_init(pConfig: *ma_hishelf2_config, pFilter: *ma_hishelf2): ma_result <cimport, nodecl> end
global function ma_hishelf2_reinit(pConfig: *ma_hishelf2_config, pFilter: *ma_hishelf2): ma_result <cimport, nodecl> end
global function ma_hishelf2_process_pcm_frames(pFilter: *ma_hishelf2, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_hishelf2_get_latency(pFilter: *ma_hishelf2): uint32 <cimport, nodecl> end
global ma_linear_resampler_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRateIn: uint32,
  sampleRateOut: uint32,
  lpfOrder: uint32,
  lpfNyquistFactor: float64
}
global function ma_linear_resampler_config_init(format: ma_format, channels: uint32, sampleRateIn: uint32, sampleRateOut: uint32): ma_linear_resampler_config <cimport, nodecl> end
global ma_linear_resampler: type <cimport, nodecl> = @record{
  config: ma_linear_resampler_config,
  inAdvanceInt: uint32,
  inAdvanceFrac: uint32,
  inTimeInt: uint32,
  inTimeFrac: uint32,
  x0: union{
    f32: [32]float32,
    s16: [32]int16
  },
  x1: union{
    f32: [32]float32,
    s16: [32]int16
  },
  lpf: ma_lpf
}
global function ma_linear_resampler_init(pConfig: *ma_linear_resampler_config, pResampler: *ma_linear_resampler): ma_result <cimport, nodecl> end
global function ma_linear_resampler_uninit(pResampler: *ma_linear_resampler) <cimport, nodecl> end
global function ma_linear_resampler_process_pcm_frames(pResampler: *ma_linear_resampler, pFramesIn: pointer, pFrameCountIn: *uint64, pFramesOut: pointer, pFrameCountOut: *uint64): ma_result <cimport, nodecl> end
global function ma_linear_resampler_set_rate(pResampler: *ma_linear_resampler, sampleRateIn: uint32, sampleRateOut: uint32): ma_result <cimport, nodecl> end
global function ma_linear_resampler_set_rate_ratio(pResampler: *ma_linear_resampler, ratioInOut: float32): ma_result <cimport, nodecl> end
global function ma_linear_resampler_get_required_input_frame_count(pResampler: *ma_linear_resampler, outputFrameCount: uint64): uint64 <cimport, nodecl> end
global function ma_linear_resampler_get_expected_output_frame_count(pResampler: *ma_linear_resampler, inputFrameCount: uint64): uint64 <cimport, nodecl> end
global function ma_linear_resampler_get_input_latency(pResampler: *ma_linear_resampler): uint64 <cimport, nodecl> end
global function ma_linear_resampler_get_output_latency(pResampler: *ma_linear_resampler): uint64 <cimport, nodecl> end
global ma_resample_algorithm: type <cimport, nodecl, using> = @enum(cint){
  ma_resample_algorithm_linear = 0,
  ma_resample_algorithm_speex = 1
}
global ma_resampler_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRateIn: uint32,
  sampleRateOut: uint32,
  algorithm: ma_resample_algorithm,
  linear: record{
    lpfOrder: uint32,
    lpfNyquistFactor: float64
  },
  speex: record{
    quality: cint
  }
}
global function ma_resampler_config_init(format: ma_format, channels: uint32, sampleRateIn: uint32, sampleRateOut: uint32, algorithm: ma_resample_algorithm): ma_resampler_config <cimport, nodecl> end
global ma_resampler: type <cimport, nodecl> = @record{
  config: ma_resampler_config,
  state: union{
    linear: ma_linear_resampler,
    speex: record{
      pSpeexResamplerState: pointer
    }
  }
}
global function ma_resampler_init(pConfig: *ma_resampler_config, pResampler: *ma_resampler): ma_result <cimport, nodecl> end
global function ma_resampler_uninit(pResampler: *ma_resampler) <cimport, nodecl> end
global function ma_resampler_process_pcm_frames(pResampler: *ma_resampler, pFramesIn: pointer, pFrameCountIn: *uint64, pFramesOut: pointer, pFrameCountOut: *uint64): ma_result <cimport, nodecl> end
global function ma_resampler_set_rate(pResampler: *ma_resampler, sampleRateIn: uint32, sampleRateOut: uint32): ma_result <cimport, nodecl> end
global function ma_resampler_set_rate_ratio(pResampler: *ma_resampler, ratio: float32): ma_result <cimport, nodecl> end
global function ma_resampler_get_required_input_frame_count(pResampler: *ma_resampler, outputFrameCount: uint64): uint64 <cimport, nodecl> end
global function ma_resampler_get_expected_output_frame_count(pResampler: *ma_resampler, inputFrameCount: uint64): uint64 <cimport, nodecl> end
global function ma_resampler_get_input_latency(pResampler: *ma_resampler): uint64 <cimport, nodecl> end
global function ma_resampler_get_output_latency(pResampler: *ma_resampler): uint64 <cimport, nodecl> end
global ma_channel_converter_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channelsIn: uint32,
  channelsOut: uint32,
  channelMapIn: [32]cuchar,
  channelMapOut: [32]cuchar,
  mixingMode: ma_channel_mix_mode,
  weights: [32][32]float32
}
global function ma_channel_converter_config_init(format: ma_format, channelsIn: uint32, pChannelMapIn: *cuchar, channelsOut: uint32, pChannelMapOut: *cuchar, mixingMode: ma_channel_mix_mode): ma_channel_converter_config <cimport, nodecl> end
global ma_channel_converter: type <cimport, nodecl> = @record{
  format: ma_format,
  channelsIn: uint32,
  channelsOut: uint32,
  channelMapIn: [32]cuchar,
  channelMapOut: [32]cuchar,
  mixingMode: ma_channel_mix_mode,
  weights: union{
    f32: [32][32]float32,
    s16: [32][32]int32
  },
  isPassthrough: ma_bool8,
  isSimpleShuffle: ma_bool8,
  isSimpleMonoExpansion: ma_bool8,
  isStereoToMono: ma_bool8,
  shuffleTable: [32]uint8
}
global function ma_channel_converter_init(pConfig: *ma_channel_converter_config, pConverter: *ma_channel_converter): ma_result <cimport, nodecl> end
global function ma_channel_converter_uninit(pConverter: *ma_channel_converter) <cimport, nodecl> end
global function ma_channel_converter_process_pcm_frames(pConverter: *ma_channel_converter, pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global ma_data_converter_config: type <cimport, nodecl> = @record{
  formatIn: ma_format,
  formatOut: ma_format,
  channelsIn: uint32,
  channelsOut: uint32,
  sampleRateIn: uint32,
  sampleRateOut: uint32,
  channelMapIn: [32]cuchar,
  channelMapOut: [32]cuchar,
  ditherMode: ma_dither_mode,
  channelMixMode: ma_channel_mix_mode,
  channelWeights: [32][32]float32,
  resampling: record{
    algorithm: ma_resample_algorithm,
    allowDynamicSampleRate: ma_bool32,
    linear: record{
      lpfOrder: uint32,
      lpfNyquistFactor: float64
    },
    speex: record{
      quality: cint
    }
  }
}
global function ma_data_converter_config_init_default(): ma_data_converter_config <cimport, nodecl> end
global function ma_data_converter_config_init(formatIn: ma_format, formatOut: ma_format, channelsIn: uint32, channelsOut: uint32, sampleRateIn: uint32, sampleRateOut: uint32): ma_data_converter_config <cimport, nodecl> end
global ma_data_converter: type <cimport, nodecl> = @record{
  config: ma_data_converter_config,
  channelConverter: ma_channel_converter,
  resampler: ma_resampler,
  hasPreFormatConversion: ma_bool8,
  hasPostFormatConversion: ma_bool8,
  hasChannelConverter: ma_bool8,
  hasResampler: ma_bool8,
  isPassthrough: ma_bool8
}
global function ma_data_converter_init(pConfig: *ma_data_converter_config, pConverter: *ma_data_converter): ma_result <cimport, nodecl> end
global function ma_data_converter_uninit(pConverter: *ma_data_converter) <cimport, nodecl> end
global function ma_data_converter_process_pcm_frames(pConverter: *ma_data_converter, pFramesIn: pointer, pFrameCountIn: *uint64, pFramesOut: pointer, pFrameCountOut: *uint64): ma_result <cimport, nodecl> end
global function ma_data_converter_set_rate(pConverter: *ma_data_converter, sampleRateIn: uint32, sampleRateOut: uint32): ma_result <cimport, nodecl> end
global function ma_data_converter_set_rate_ratio(pConverter: *ma_data_converter, ratioInOut: float32): ma_result <cimport, nodecl> end
global function ma_data_converter_get_required_input_frame_count(pConverter: *ma_data_converter, outputFrameCount: uint64): uint64 <cimport, nodecl> end
global function ma_data_converter_get_expected_output_frame_count(pConverter: *ma_data_converter, inputFrameCount: uint64): uint64 <cimport, nodecl> end
global function ma_data_converter_get_input_latency(pConverter: *ma_data_converter): uint64 <cimport, nodecl> end
global function ma_data_converter_get_output_latency(pConverter: *ma_data_converter): uint64 <cimport, nodecl> end
global function ma_pcm_u8_to_s16(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_u8_to_s24(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_u8_to_s32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_u8_to_f32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s16_to_u8(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s16_to_s24(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s16_to_s32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s16_to_f32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s24_to_u8(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s24_to_s16(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s24_to_s32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s24_to_f32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s32_to_u8(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s32_to_s16(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s32_to_s24(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_s32_to_f32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_f32_to_u8(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_f32_to_s16(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_f32_to_s24(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_f32_to_s32(pOut: pointer, pIn: pointer, count: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_pcm_convert(pOut: pointer, formatOut: ma_format, pIn: pointer, formatIn: ma_format, sampleCount: uint64, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_convert_pcm_frames_format(pOut: pointer, formatOut: ma_format, pIn: pointer, formatIn: ma_format, frameCount: uint64, channels: uint32, ditherMode: ma_dither_mode) <cimport, nodecl> end
global function ma_deinterleave_pcm_frames(format: ma_format, channels: uint32, frameCount: uint64, pInterleavedPCMFrames: pointer, ppDeinterleavedPCMFrames: *pointer) <cimport, nodecl> end
global function ma_interleave_pcm_frames(format: ma_format, channels: uint32, frameCount: uint64, ppDeinterleavedPCMFrames: *pointer, pInterleavedPCMFrames: pointer) <cimport, nodecl> end
global function ma_channel_map_init_blank(channels: uint32, pChannelMap: *cuchar) <cimport, nodecl> end
global function ma_get_standard_channel_map(standardChannelMap: ma_standard_channel_map, channels: uint32, pChannelMap: *cuchar) <cimport, nodecl> end
global function ma_channel_map_copy(pOut: *cuchar, pIn: *cuchar, channels: uint32) <cimport, nodecl> end
global function ma_channel_map_copy_or_default(pOut: *cuchar, pIn: *cuchar, channels: uint32) <cimport, nodecl> end
global function ma_channel_map_valid(channels: uint32, pChannelMap: *cuchar): ma_bool32 <cimport, nodecl> end
global function ma_channel_map_equal(channels: uint32, pChannelMapA: *cuchar, pChannelMapB: *cuchar): ma_bool32 <cimport, nodecl> end
global function ma_channel_map_blank(channels: uint32, pChannelMap: *cuchar): ma_bool32 <cimport, nodecl> end
global function ma_channel_map_contains_channel_position(channels: uint32, pChannelMap: *cuchar, channelPosition: cuchar): ma_bool32 <cimport, nodecl> end
global function ma_convert_frames(pOut: pointer, frameCountOut: uint64, formatOut: ma_format, channelsOut: uint32, sampleRateOut: uint32, pIn: pointer, frameCountIn: uint64, formatIn: ma_format, channelsIn: uint32, sampleRateIn: uint32): uint64 <cimport, nodecl> end
global function ma_convert_frames_ex(pOut: pointer, frameCountOut: uint64, pIn: pointer, frameCountIn: uint64, pConfig: *ma_data_converter_config): uint64 <cimport, nodecl> end
global ma_rb: type <cimport, nodecl> = @record{
  pBuffer: pointer,
  subbufferSizeInBytes: uint32,
  subbufferCount: uint32,
  subbufferStrideInBytes: uint32,
  encodedReadOffset: uint32,
  encodedWriteOffset: uint32,
  ownsBuffer: ma_bool8,
  clearOnWriteAcquire: ma_bool8,
  allocationCallbacks: ma_allocation_callbacks
}
global function ma_rb_init_ex(subbufferSizeInBytes: csize, subbufferCount: csize, subbufferStrideInBytes: csize, pOptionalPreallocatedBuffer: pointer, pAllocationCallbacks: *ma_allocation_callbacks, pRB: *ma_rb): ma_result <cimport, nodecl> end
global function ma_rb_init(bufferSizeInBytes: csize, pOptionalPreallocatedBuffer: pointer, pAllocationCallbacks: *ma_allocation_callbacks, pRB: *ma_rb): ma_result <cimport, nodecl> end
global function ma_rb_uninit(pRB: *ma_rb) <cimport, nodecl> end
global function ma_rb_reset(pRB: *ma_rb) <cimport, nodecl> end
global function ma_rb_acquire_read(pRB: *ma_rb, pSizeInBytes: *csize, ppBufferOut: *pointer): ma_result <cimport, nodecl> end
global function ma_rb_commit_read(pRB: *ma_rb, sizeInBytes: csize, pBufferOut: pointer): ma_result <cimport, nodecl> end
global function ma_rb_acquire_write(pRB: *ma_rb, pSizeInBytes: *csize, ppBufferOut: *pointer): ma_result <cimport, nodecl> end
global function ma_rb_commit_write(pRB: *ma_rb, sizeInBytes: csize, pBufferOut: pointer): ma_result <cimport, nodecl> end
global function ma_rb_seek_read(pRB: *ma_rb, offsetInBytes: csize): ma_result <cimport, nodecl> end
global function ma_rb_seek_write(pRB: *ma_rb, offsetInBytes: csize): ma_result <cimport, nodecl> end
global function ma_rb_pointer_distance(pRB: *ma_rb): int32 <cimport, nodecl> end
global function ma_rb_available_read(pRB: *ma_rb): uint32 <cimport, nodecl> end
global function ma_rb_available_write(pRB: *ma_rb): uint32 <cimport, nodecl> end
global function ma_rb_get_subbuffer_size(pRB: *ma_rb): csize <cimport, nodecl> end
global function ma_rb_get_subbuffer_stride(pRB: *ma_rb): csize <cimport, nodecl> end
global function ma_rb_get_subbuffer_offset(pRB: *ma_rb, subbufferIndex: csize): csize <cimport, nodecl> end
global function ma_rb_get_subbuffer_ptr(pRB: *ma_rb, subbufferIndex: csize, pBuffer: pointer): pointer <cimport, nodecl> end
global ma_pcm_rb: type <cimport, nodecl> = @record{
  rb: ma_rb,
  format: ma_format,
  channels: uint32
}
global function ma_pcm_rb_init_ex(format: ma_format, channels: uint32, subbufferSizeInFrames: uint32, subbufferCount: uint32, subbufferStrideInFrames: uint32, pOptionalPreallocatedBuffer: pointer, pAllocationCallbacks: *ma_allocation_callbacks, pRB: *ma_pcm_rb): ma_result <cimport, nodecl> end
global function ma_pcm_rb_init(format: ma_format, channels: uint32, bufferSizeInFrames: uint32, pOptionalPreallocatedBuffer: pointer, pAllocationCallbacks: *ma_allocation_callbacks, pRB: *ma_pcm_rb): ma_result <cimport, nodecl> end
global function ma_pcm_rb_uninit(pRB: *ma_pcm_rb) <cimport, nodecl> end
global function ma_pcm_rb_reset(pRB: *ma_pcm_rb) <cimport, nodecl> end
global function ma_pcm_rb_acquire_read(pRB: *ma_pcm_rb, pSizeInFrames: *uint32, ppBufferOut: *pointer): ma_result <cimport, nodecl> end
global function ma_pcm_rb_commit_read(pRB: *ma_pcm_rb, sizeInFrames: uint32, pBufferOut: pointer): ma_result <cimport, nodecl> end
global function ma_pcm_rb_acquire_write(pRB: *ma_pcm_rb, pSizeInFrames: *uint32, ppBufferOut: *pointer): ma_result <cimport, nodecl> end
global function ma_pcm_rb_commit_write(pRB: *ma_pcm_rb, sizeInFrames: uint32, pBufferOut: pointer): ma_result <cimport, nodecl> end
global function ma_pcm_rb_seek_read(pRB: *ma_pcm_rb, offsetInFrames: uint32): ma_result <cimport, nodecl> end
global function ma_pcm_rb_seek_write(pRB: *ma_pcm_rb, offsetInFrames: uint32): ma_result <cimport, nodecl> end
global function ma_pcm_rb_pointer_distance(pRB: *ma_pcm_rb): int32 <cimport, nodecl> end
global function ma_pcm_rb_available_read(pRB: *ma_pcm_rb): uint32 <cimport, nodecl> end
global function ma_pcm_rb_available_write(pRB: *ma_pcm_rb): uint32 <cimport, nodecl> end
global function ma_pcm_rb_get_subbuffer_size(pRB: *ma_pcm_rb): uint32 <cimport, nodecl> end
global function ma_pcm_rb_get_subbuffer_stride(pRB: *ma_pcm_rb): uint32 <cimport, nodecl> end
global function ma_pcm_rb_get_subbuffer_offset(pRB: *ma_pcm_rb, subbufferIndex: uint32): uint32 <cimport, nodecl> end
global function ma_pcm_rb_get_subbuffer_ptr(pRB: *ma_pcm_rb, subbufferIndex: uint32, pBuffer: pointer): pointer <cimport, nodecl> end
global ma_duplex_rb: type <cimport, nodecl> = @record{
  rb: ma_pcm_rb
}
global function ma_duplex_rb_init(captureFormat: ma_format, captureChannels: uint32, sampleRate: uint32, captureInternalSampleRate: uint32, captureInternalPeriodSizeInFrames: uint32, pAllocationCallbacks: *ma_allocation_callbacks, pRB: *ma_duplex_rb): ma_result <cimport, nodecl> end
global function ma_duplex_rb_uninit(pRB: *ma_duplex_rb): ma_result <cimport, nodecl> end
global function ma_result_description(result: ma_result): cstring <cimport, nodecl> end
global function ma_malloc(sz: csize, pAllocationCallbacks: *ma_allocation_callbacks): pointer <cimport, nodecl> end
global function ma_realloc(p: pointer, sz: csize, pAllocationCallbacks: *ma_allocation_callbacks): pointer <cimport, nodecl> end
global function ma_free(p: pointer, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global function ma_aligned_malloc(sz: csize, alignment: csize, pAllocationCallbacks: *ma_allocation_callbacks): pointer <cimport, nodecl> end
global function ma_aligned_free(p: pointer, pAllocationCallbacks: *ma_allocation_callbacks) <cimport, nodecl> end
global function ma_get_format_name(format: ma_format): cstring <cimport, nodecl> end
global function ma_blend_f32(pOut: *float32, pInA: *float32, pInB: *float32, factor: float32, channels: uint32) <cimport, nodecl> end
global function ma_get_bytes_per_sample(format: ma_format): uint32 <cimport, nodecl> end
global function ma_get_bytes_per_frame(format: ma_format, channels: uint32): uint32 <cimport, nodecl> end
global function ma_log_level_to_string(logLevel: uint32): cstring <cimport, nodecl> end
global ma_backend: type <cimport, nodecl, using> = @enum(cint){
  ma_backend_wasapi = 0,
  ma_backend_dsound = 1,
  ma_backend_winmm = 2,
  ma_backend_coreaudio = 3,
  ma_backend_sndio = 4,
  ma_backend_audio4 = 5,
  ma_backend_oss = 6,
  ma_backend_pulseaudio = 7,
  ma_backend_alsa = 8,
  ma_backend_jack = 9,
  ma_backend_aaudio = 10,
  ma_backend_opensl = 11,
  ma_backend_webaudio = 12,
  ma_backend_custom = 13,
  ma_backend_null = 14
}
global ma_device_callback_proc: type <cimport, nodecl> = @function(*ma_device, pointer, pointer, uint32)
global ma_stop_proc: type <cimport, nodecl> = @function(*ma_device)
global ma_log_proc: type <cimport, nodecl> = @function(*ma_context, *ma_device, uint32, cstring)
global ma_device_type: type <cimport, nodecl, using> = @enum(cint){
  ma_device_type_playback = 1,
  ma_device_type_capture = 2,
  ma_device_type_duplex = 3,
  ma_device_type_loopback = 4
}
global ma_share_mode: type <cimport, nodecl, using> = @enum(cint){
  ma_share_mode_shared = 0,
  ma_share_mode_exclusive = 1
}
global ma_ios_session_category: type <cimport, nodecl, using> = @enum(cint){
  ma_ios_session_category_default = 0,
  ma_ios_session_category_none = 1,
  ma_ios_session_category_ambient = 2,
  ma_ios_session_category_solo_ambient = 3,
  ma_ios_session_category_playback = 4,
  ma_ios_session_category_record = 5,
  ma_ios_session_category_play_and_record = 6,
  ma_ios_session_category_multi_route = 7
}
global ma_ios_session_category_option: type <cimport, nodecl, using> = @enum(cint){
  ma_ios_session_category_option_mix_with_others = 1,
  ma_ios_session_category_option_duck_others = 2,
  ma_ios_session_category_option_allow_bluetooth = 4,
  ma_ios_session_category_option_default_to_speaker = 8,
  ma_ios_session_category_option_interrupt_spoken_audio_and_mix_with_others = 17,
  ma_ios_session_category_option_allow_bluetooth_a2dp = 32,
  ma_ios_session_category_option_allow_air_play = 64
}
global ma_opensl_stream_type: type <cimport, nodecl, using> = @enum(cint){
  ma_opensl_stream_type_default = 0,
  ma_opensl_stream_type_voice = 1,
  ma_opensl_stream_type_system = 2,
  ma_opensl_stream_type_ring = 3,
  ma_opensl_stream_type_media = 4,
  ma_opensl_stream_type_alarm = 5,
  ma_opensl_stream_type_notification = 6
}
global ma_opensl_recording_preset: type <cimport, nodecl, using> = @enum(cint){
  ma_opensl_recording_preset_default = 0,
  ma_opensl_recording_preset_generic = 1,
  ma_opensl_recording_preset_camcorder = 2,
  ma_opensl_recording_preset_voice_recognition = 3,
  ma_opensl_recording_preset_voice_communication = 4,
  ma_opensl_recording_preset_voice_unprocessed = 5
}
global ma_aaudio_usage: type <cimport, nodecl, using> = @enum(cint){
  ma_aaudio_usage_default = 0,
  ma_aaudio_usage_announcement = 1,
  ma_aaudio_usage_emergency = 2,
  ma_aaudio_usage_safety = 3,
  ma_aaudio_usage_vehicle_status = 4,
  ma_aaudio_usage_alarm = 5,
  ma_aaudio_usage_assistance_accessibility = 6,
  ma_aaudio_usage_assistance_navigation_guidance = 7,
  ma_aaudio_usage_assistance_sonification = 8,
  ma_aaudio_usage_assitant = 9,
  ma_aaudio_usage_game = 10,
  ma_aaudio_usage_media = 11,
  ma_aaudio_usage_notification = 12,
  ma_aaudio_usage_notification_event = 13,
  ma_aaudio_usage_notification_ringtone = 14,
  ma_aaudio_usage_voice_communication = 15,
  ma_aaudio_usage_voice_communication_signalling = 16
}
global ma_aaudio_content_type: type <cimport, nodecl, using> = @enum(cint){
  ma_aaudio_content_type_default = 0,
  ma_aaudio_content_type_movie = 1,
  ma_aaudio_content_type_music = 2,
  ma_aaudio_content_type_sonification = 3,
  ma_aaudio_content_type_speech = 4
}
global ma_aaudio_input_preset: type <cimport, nodecl, using> = @enum(cint){
  ma_aaudio_input_preset_default = 0,
  ma_aaudio_input_preset_generic = 1,
  ma_aaudio_input_preset_camcorder = 2,
  ma_aaudio_input_preset_unprocessed = 3,
  ma_aaudio_input_preset_voice_recognition = 4,
  ma_aaudio_input_preset_voice_communication = 5,
  ma_aaudio_input_preset_voice_performance = 6
}
global ma_timer: type <cimport, nodecl> = @union{
  counter: int64,
  counterD: float64
}
global ma_device_id: type <cimport, nodecl> = @union{
  wasapi: [64]cint,
  dsound: [16]uint8,
  winmm: uint32,
  alsa: [256]cchar,
  pulse: [256]cchar,
  jack: cint,
  coreaudio: [256]cchar,
  sndio: [256]cchar,
  audio4: [256]cchar,
  oss: [64]cchar,
  aaudio: int32,
  opensl: uint32,
  webaudio: [32]cchar,
  custom: union{
    i: cint,
    s: [256]cchar,
    p: pointer
  },
  nullbackend: cint
}
global ma_context_config: type <cimport, nodecl, forwarddecl> = @record{}
global ma_device_config: type <cimport, nodecl, forwarddecl> = @record{}
global ma_backend_callbacks: type <cimport, nodecl, forwarddecl> = @record{}
global ma_device_info: type <cimport, nodecl> = @record{
  id: ma_device_id,
  name: [256]cchar,
  isDefault: ma_bool32,
  formatCount: uint32,
  formats: [6]ma_format,
  minChannels: uint32,
  maxChannels: uint32,
  minSampleRate: uint32,
  maxSampleRate: uint32,
  nativeDataFormatCount: uint32,
  nativeDataFormats: [64]record{
    format: ma_format,
    channels: uint32,
    sampleRate: uint32,
    flags: uint32
  }
}
ma_device_config = @record{
  deviceType: ma_device_type,
  sampleRate: uint32,
  periodSizeInFrames: uint32,
  periodSizeInMilliseconds: uint32,
  periods: uint32,
  performanceProfile: ma_performance_profile,
  noPreZeroedOutputBuffer: ma_bool8,
  noClip: ma_bool8,
  dataCallback: ma_device_callback_proc,
  stopCallback: ma_stop_proc,
  pUserData: pointer,
  resampling: record{
    algorithm: ma_resample_algorithm,
    linear: record{
      lpfOrder: uint32
    },
    speex: record{
      quality: cint
    }
  },
  playback: record{
    pDeviceID: *ma_device_id,
    format: ma_format,
    channels: uint32,
    channelMap: [32]cuchar,
    channelMixMode: ma_channel_mix_mode,
    shareMode: ma_share_mode
  },
  capture: record{
    pDeviceID: *ma_device_id,
    format: ma_format,
    channels: uint32,
    channelMap: [32]cuchar,
    channelMixMode: ma_channel_mix_mode,
    shareMode: ma_share_mode
  },
  wasapi: record{
    noAutoConvertSRC: ma_bool8,
    noDefaultQualitySRC: ma_bool8,
    noAutoStreamRouting: ma_bool8,
    noHardwareOffloading: ma_bool8
  },
  alsa: record{
    noMMap: ma_bool32,
    noAutoFormat: ma_bool32,
    noAutoChannels: ma_bool32,
    noAutoResample: ma_bool32
  },
  pulse: record{
    pStreamNamePlayback: cstring,
    pStreamNameCapture: cstring
  },
  coreaudio: record{
    allowNominalSampleRateChange: ma_bool32
  },
  opensl: record{
    streamType: ma_opensl_stream_type,
    recordingPreset: ma_opensl_recording_preset
  },
  aaudio: record{
    usage: ma_aaudio_usage,
    contentType: ma_aaudio_content_type,
    inputPreset: ma_aaudio_input_preset
  }
}
global ma_enum_devices_callback_proc: type <cimport, nodecl> = @function(*ma_context, ma_device_type, *ma_device_info, pointer): ma_bool32
global ma_device_descriptor: type <cimport, nodecl> = @record{
  pDeviceID: *ma_device_id,
  shareMode: ma_share_mode,
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  channelMap: [32]cuchar,
  periodSizeInFrames: uint32,
  periodSizeInMilliseconds: uint32,
  periodCount: uint32
}
ma_backend_callbacks = @record{
  onContextInit: function(*ma_context, *ma_context_config, *ma_backend_callbacks): ma_result,
  onContextUninit: function(*ma_context): ma_result,
  onContextEnumerateDevices: function(*ma_context, ma_enum_devices_callback_proc, pointer): ma_result,
  onContextGetDeviceInfo: function(*ma_context, ma_device_type, *ma_device_id, *ma_device_info): ma_result,
  onDeviceInit: function(*ma_device, *ma_device_config, *ma_device_descriptor, *ma_device_descriptor): ma_result,
  onDeviceUninit: function(*ma_device): ma_result,
  onDeviceStart: function(*ma_device): ma_result,
  onDeviceStop: function(*ma_device): ma_result,
  onDeviceRead: function(*ma_device, pointer, uint32, *uint32): ma_result,
  onDeviceWrite: function(*ma_device, pointer, uint32, *uint32): ma_result,
  onDeviceDataLoop: function(*ma_device): ma_result,
  onDeviceDataLoopWakeup: function(*ma_device): ma_result
}
ma_context_config = @record{
  logCallback: ma_log_proc,
  threadPriority: ma_thread_priority,
  threadStackSize: csize,
  pUserData: pointer,
  allocationCallbacks: ma_allocation_callbacks,
  alsa: record{
    useVerboseDeviceEnumeration: ma_bool32
  },
  pulse: record{
    pApplicationName: cstring,
    pServerName: cstring,
    tryAutoSpawn: ma_bool32
  },
  coreaudio: record{
    sessionCategory: ma_ios_session_category,
    sessionCategoryOptions: uint32,
    noAudioSessionActivate: ma_bool32,
    noAudioSessionDeactivate: ma_bool32
  },
  jack: record{
    pClientName: cstring,
    tryStartServer: ma_bool32
  },
  custom: ma_backend_callbacks
}
ma_context = @record{
  callbacks: ma_backend_callbacks,
  backend: ma_backend,
  logCallback: ma_log_proc,
  threadPriority: ma_thread_priority,
  threadStackSize: csize,
  pUserData: pointer,
  allocationCallbacks: ma_allocation_callbacks,
  deviceEnumLock: ma_mutex,
  deviceInfoLock: ma_mutex,
  deviceInfoCapacity: uint32,
  playbackDeviceInfoCount: uint32,
  captureDeviceInfoCount: uint32,
  pDeviceInfos: *ma_device_info,
  __unnamed1: union{
    alsa: record{
      asoundSO: ma_handle,
      snd_pcm_open: ma_proc,
      snd_pcm_close: ma_proc,
      snd_pcm_hw_params_sizeof: ma_proc,
      snd_pcm_hw_params_any: ma_proc,
      snd_pcm_hw_params_set_format: ma_proc,
      snd_pcm_hw_params_set_format_first: ma_proc,
      snd_pcm_hw_params_get_format_mask: ma_proc,
      snd_pcm_hw_params_set_channels: ma_proc,
      snd_pcm_hw_params_set_channels_near: ma_proc,
      snd_pcm_hw_params_set_channels_minmax: ma_proc,
      snd_pcm_hw_params_set_rate_resample: ma_proc,
      snd_pcm_hw_params_set_rate: ma_proc,
      snd_pcm_hw_params_set_rate_near: ma_proc,
      snd_pcm_hw_params_set_buffer_size_near: ma_proc,
      snd_pcm_hw_params_set_periods_near: ma_proc,
      snd_pcm_hw_params_set_access: ma_proc,
      snd_pcm_hw_params_get_format: ma_proc,
      snd_pcm_hw_params_get_channels: ma_proc,
      snd_pcm_hw_params_get_channels_min: ma_proc,
      snd_pcm_hw_params_get_channels_max: ma_proc,
      snd_pcm_hw_params_get_rate: ma_proc,
      snd_pcm_hw_params_get_rate_min: ma_proc,
      snd_pcm_hw_params_get_rate_max: ma_proc,
      snd_pcm_hw_params_get_buffer_size: ma_proc,
      snd_pcm_hw_params_get_periods: ma_proc,
      snd_pcm_hw_params_get_access: ma_proc,
      snd_pcm_hw_params_test_format: ma_proc,
      snd_pcm_hw_params_test_channels: ma_proc,
      snd_pcm_hw_params_test_rate: ma_proc,
      snd_pcm_hw_params: ma_proc,
      snd_pcm_sw_params_sizeof: ma_proc,
      snd_pcm_sw_params_current: ma_proc,
      snd_pcm_sw_params_get_boundary: ma_proc,
      snd_pcm_sw_params_set_avail_min: ma_proc,
      snd_pcm_sw_params_set_start_threshold: ma_proc,
      snd_pcm_sw_params_set_stop_threshold: ma_proc,
      snd_pcm_sw_params: ma_proc,
      snd_pcm_format_mask_sizeof: ma_proc,
      snd_pcm_format_mask_test: ma_proc,
      snd_pcm_get_chmap: ma_proc,
      snd_pcm_state: ma_proc,
      snd_pcm_prepare: ma_proc,
      snd_pcm_start: ma_proc,
      snd_pcm_drop: ma_proc,
      snd_pcm_drain: ma_proc,
      snd_device_name_hint: ma_proc,
      snd_device_name_get_hint: ma_proc,
      snd_card_get_index: ma_proc,
      snd_device_name_free_hint: ma_proc,
      snd_pcm_mmap_begin: ma_proc,
      snd_pcm_mmap_commit: ma_proc,
      snd_pcm_recover: ma_proc,
      snd_pcm_readi: ma_proc,
      snd_pcm_writei: ma_proc,
      snd_pcm_avail: ma_proc,
      snd_pcm_avail_update: ma_proc,
      snd_pcm_wait: ma_proc,
      snd_pcm_info: ma_proc,
      snd_pcm_info_sizeof: ma_proc,
      snd_pcm_info_get_name: ma_proc,
      snd_config_update_free_global: ma_proc,
      internalDeviceEnumLock: ma_mutex,
      useVerboseDeviceEnumeration: ma_bool32
    },
    pulse: record{
      pulseSO: ma_handle,
      pa_mainloop_new: ma_proc,
      pa_mainloop_free: ma_proc,
      pa_mainloop_quit: ma_proc,
      pa_mainloop_get_api: ma_proc,
      pa_mainloop_iterate: ma_proc,
      pa_mainloop_wakeup: ma_proc,
      pa_threaded_mainloop_new: ma_proc,
      pa_threaded_mainloop_free: ma_proc,
      pa_threaded_mainloop_start: ma_proc,
      pa_threaded_mainloop_stop: ma_proc,
      pa_threaded_mainloop_lock: ma_proc,
      pa_threaded_mainloop_unlock: ma_proc,
      pa_threaded_mainloop_wait: ma_proc,
      pa_threaded_mainloop_signal: ma_proc,
      pa_threaded_mainloop_accept: ma_proc,
      pa_threaded_mainloop_get_retval: ma_proc,
      pa_threaded_mainloop_get_api: ma_proc,
      pa_threaded_mainloop_in_thread: ma_proc,
      pa_threaded_mainloop_set_name: ma_proc,
      pa_context_new: ma_proc,
      pa_context_unref: ma_proc,
      pa_context_connect: ma_proc,
      pa_context_disconnect: ma_proc,
      pa_context_set_state_callback: ma_proc,
      pa_context_get_state: ma_proc,
      pa_context_get_sink_info_list: ma_proc,
      pa_context_get_source_info_list: ma_proc,
      pa_context_get_sink_info_by_name: ma_proc,
      pa_context_get_source_info_by_name: ma_proc,
      pa_operation_unref: ma_proc,
      pa_operation_get_state: ma_proc,
      pa_channel_map_init_extend: ma_proc,
      pa_channel_map_valid: ma_proc,
      pa_channel_map_compatible: ma_proc,
      pa_stream_new: ma_proc,
      pa_stream_unref: ma_proc,
      pa_stream_connect_playback: ma_proc,
      pa_stream_connect_record: ma_proc,
      pa_stream_disconnect: ma_proc,
      pa_stream_get_state: ma_proc,
      pa_stream_get_sample_spec: ma_proc,
      pa_stream_get_channel_map: ma_proc,
      pa_stream_get_buffer_attr: ma_proc,
      pa_stream_set_buffer_attr: ma_proc,
      pa_stream_get_device_name: ma_proc,
      pa_stream_set_write_callback: ma_proc,
      pa_stream_set_read_callback: ma_proc,
      pa_stream_flush: ma_proc,
      pa_stream_drain: ma_proc,
      pa_stream_is_corked: ma_proc,
      pa_stream_cork: ma_proc,
      pa_stream_trigger: ma_proc,
      pa_stream_begin_write: ma_proc,
      pa_stream_write: ma_proc,
      pa_stream_peek: ma_proc,
      pa_stream_drop: ma_proc,
      pa_stream_writable_size: ma_proc,
      pa_stream_readable_size: ma_proc,
      pMainLoop: ma_ptr,
      pPulseContext: ma_ptr
    },
    jack: record{
      jackSO: ma_handle,
      jack_client_open: ma_proc,
      jack_client_close: ma_proc,
      jack_client_name_size: ma_proc,
      jack_set_process_callback: ma_proc,
      jack_set_buffer_size_callback: ma_proc,
      jack_on_shutdown: ma_proc,
      jack_get_sample_rate: ma_proc,
      jack_get_buffer_size: ma_proc,
      jack_get_ports: ma_proc,
      jack_activate: ma_proc,
      jack_deactivate: ma_proc,
      jack_connect: ma_proc,
      jack_port_register: ma_proc,
      jack_port_name: ma_proc,
      jack_port_get_buffer: ma_proc,
      jack_free: ma_proc,
      pClientName: cstring,
      tryStartServer: ma_bool32
    },
    null_backend: record{
      _unused: cint
    }
  },
  __unnamed2: union{
    posix: record{
      pthreadSO: ma_handle,
      pthread_create: ma_proc,
      pthread_join: ma_proc,
      pthread_mutex_init: ma_proc,
      pthread_mutex_destroy: ma_proc,
      pthread_mutex_lock: ma_proc,
      pthread_mutex_unlock: ma_proc,
      pthread_cond_init: ma_proc,
      pthread_cond_destroy: ma_proc,
      pthread_cond_wait: ma_proc,
      pthread_cond_signal: ma_proc,
      pthread_attr_init: ma_proc,
      pthread_attr_destroy: ma_proc,
      pthread_attr_setschedpolicy: ma_proc,
      pthread_attr_getschedparam: ma_proc,
      pthread_attr_setschedparam: ma_proc
    },
    _unused: cint
  }
}
ma_device = @record{
  pContext: *ma_context,
  type: ma_device_type,
  sampleRate: uint32,
  state: uint32,
  onData: ma_device_callback_proc,
  onStop: ma_stop_proc,
  pUserData: pointer,
  startStopLock: ma_mutex,
  wakeupEvent: ma_event,
  startEvent: ma_event,
  stopEvent: ma_event,
  thread: culong,
  workResult: ma_result,
  isOwnerOfContext: ma_bool8,
  noPreZeroedOutputBuffer: ma_bool8,
  noClip: ma_bool8,
  masterVolumeFactor: float32,
  duplexRB: ma_duplex_rb,
  resampling: record{
    algorithm: ma_resample_algorithm,
    linear: record{
      lpfOrder: uint32
    },
    speex: record{
      quality: cint
    }
  },
  playback: record{
    id: ma_device_id,
    name: [256]cchar,
    shareMode: ma_share_mode,
    format: ma_format,
    channels: uint32,
    channelMap: [32]cuchar,
    internalFormat: ma_format,
    internalChannels: uint32,
    internalSampleRate: uint32,
    internalChannelMap: [32]cuchar,
    internalPeriodSizeInFrames: uint32,
    internalPeriods: uint32,
    channelMixMode: ma_channel_mix_mode,
    converter: ma_data_converter
  },
  capture: record{
    id: ma_device_id,
    name: [256]cchar,
    shareMode: ma_share_mode,
    format: ma_format,
    channels: uint32,
    channelMap: [32]cuchar,
    internalFormat: ma_format,
    internalChannels: uint32,
    internalSampleRate: uint32,
    internalChannelMap: [32]cuchar,
    internalPeriodSizeInFrames: uint32,
    internalPeriods: uint32,
    channelMixMode: ma_channel_mix_mode,
    converter: ma_data_converter
  },
  __unnamed1: union{
    alsa: record{
      pPCMPlayback: ma_ptr,
      pPCMCapture: ma_ptr,
      isUsingMMapPlayback: ma_bool8,
      isUsingMMapCapture: ma_bool8
    },
    pulse: record{
      pStreamPlayback: ma_ptr,
      pStreamCapture: ma_ptr
    },
    jack: record{
      pClient: ma_ptr,
      pPortsPlayback: [32]ma_ptr,
      pPortsCapture: [32]ma_ptr,
      pIntermediaryBufferPlayback: *float32,
      pIntermediaryBufferCapture: *float32
    },
    null_device: record{
      deviceThread: culong,
      operationEvent: ma_event,
      operationCompletionEvent: ma_event,
      operationSemaphore: ma_semaphore,
      operation: uint32,
      operationResult: ma_result,
      timer: ma_timer,
      priorRunTime: float64,
      currentPeriodFramesRemainingPlayback: uint32,
      currentPeriodFramesRemainingCapture: uint32,
      lastProcessedFramePlayback: uint64,
      lastProcessedFrameCapture: uint64,
      isStarted: ma_bool8
    }
  }
}
global function ma_context_config_init(): ma_context_config <cimport, nodecl> end
global function ma_context_init(backends: *ma_backend, backendCount: uint32, pConfig: *ma_context_config, pContext: *ma_context): ma_result <cimport, nodecl> end
global function ma_context_uninit(pContext: *ma_context): ma_result <cimport, nodecl> end
global function ma_context_sizeof(): csize <cimport, nodecl> end
global function ma_context_enumerate_devices(pContext: *ma_context, callback: ma_enum_devices_callback_proc, pUserData: pointer): ma_result <cimport, nodecl> end
global function ma_context_get_devices(pContext: *ma_context, ppPlaybackDeviceInfos: **ma_device_info, pPlaybackDeviceCount: *uint32, ppCaptureDeviceInfos: **ma_device_info, pCaptureDeviceCount: *uint32): ma_result <cimport, nodecl> end
global function ma_context_get_device_info(pContext: *ma_context, deviceType: ma_device_type, pDeviceID: *ma_device_id, shareMode: ma_share_mode, pDeviceInfo: *ma_device_info): ma_result <cimport, nodecl> end
global function ma_context_is_loopback_supported(pContext: *ma_context): ma_bool32 <cimport, nodecl> end
global function ma_device_config_init(deviceType: ma_device_type): ma_device_config <cimport, nodecl> end
global function ma_device_init(pContext: *ma_context, pConfig: *ma_device_config, pDevice: *ma_device): ma_result <cimport, nodecl> end
global function ma_device_init_ex(backends: *ma_backend, backendCount: uint32, pContextConfig: *ma_context_config, pConfig: *ma_device_config, pDevice: *ma_device): ma_result <cimport, nodecl> end
global function ma_device_uninit(pDevice: *ma_device) <cimport, nodecl> end
global function ma_device_start(pDevice: *ma_device): ma_result <cimport, nodecl> end
global function ma_device_stop(pDevice: *ma_device): ma_result <cimport, nodecl> end
global function ma_device_is_started(pDevice: *ma_device): ma_bool32 <cimport, nodecl> end
global function ma_device_get_state(pDevice: *ma_device): uint32 <cimport, nodecl> end
global function ma_device_set_master_volume(pDevice: *ma_device, volume: float32): ma_result <cimport, nodecl> end
global function ma_device_get_master_volume(pDevice: *ma_device, pVolume: *float32): ma_result <cimport, nodecl> end
global function ma_device_set_master_gain_db(pDevice: *ma_device, gainDB: float32): ma_result <cimport, nodecl> end
global function ma_device_get_master_gain_db(pDevice: *ma_device, pGainDB: *float32): ma_result <cimport, nodecl> end
global function ma_device_handle_backend_data_callback(pDevice: *ma_device, pOutput: pointer, pInput: pointer, frameCount: uint32): ma_result <cimport, nodecl> end
global function ma_calculate_buffer_size_in_frames_from_descriptor(pDescriptor: *ma_device_descriptor, nativeSampleRate: uint32, performanceProfile: ma_performance_profile): uint32 <cimport, nodecl> end
global function ma_get_backend_name(backend: ma_backend): cstring <cimport, nodecl> end
global function ma_is_backend_enabled(backend: ma_backend): ma_bool32 <cimport, nodecl> end
global function ma_get_enabled_backends(pBackends: *ma_backend, backendCap: csize, pBackendCount: *csize): ma_result <cimport, nodecl> end
global function ma_is_loopback_supported(backend: ma_backend): ma_bool32 <cimport, nodecl> end
global function ma_spinlock_lock(pSpinlock: *ma_spinlock): ma_result <cimport, nodecl> end
global function ma_spinlock_lock_noyield(pSpinlock: *ma_spinlock): ma_result <cimport, nodecl> end
global function ma_spinlock_unlock(pSpinlock: *ma_spinlock): ma_result <cimport, nodecl> end
global function ma_mutex_init(pMutex: *ma_mutex): ma_result <cimport, nodecl> end
global function ma_mutex_uninit(pMutex: *ma_mutex) <cimport, nodecl> end
global function ma_mutex_lock(pMutex: *ma_mutex) <cimport, nodecl> end
global function ma_mutex_unlock(pMutex: *ma_mutex) <cimport, nodecl> end
global function ma_event_init(pEvent: *ma_event): ma_result <cimport, nodecl> end
global function ma_event_uninit(pEvent: *ma_event) <cimport, nodecl> end
global function ma_event_wait(pEvent: *ma_event): ma_result <cimport, nodecl> end
global function ma_event_signal(pEvent: *ma_event): ma_result <cimport, nodecl> end
global function ma_scale_buffer_size(baseBufferSize: uint32, scale: float32): uint32 <cimport, nodecl> end
global function ma_calculate_buffer_size_in_milliseconds_from_frames(bufferSizeInFrames: uint32, sampleRate: uint32): uint32 <cimport, nodecl> end
global function ma_calculate_buffer_size_in_frames_from_milliseconds(bufferSizeInMilliseconds: uint32, sampleRate: uint32): uint32 <cimport, nodecl> end
global function ma_copy_pcm_frames(dst: pointer, src: pointer, frameCount: uint64, format: ma_format, channels: uint32) <cimport, nodecl> end
global function ma_silence_pcm_frames(p: pointer, frameCount: uint64, format: ma_format, channels: uint32) <cimport, nodecl> end
global function ma_zero_pcm_frames(p: pointer, frameCount: uint64, format: ma_format, channels: uint32) <cimport, nodecl> end
global function ma_offset_pcm_frames_ptr(p: pointer, offsetInFrames: uint64, format: ma_format, channels: uint32): pointer <cimport, nodecl> end
global function ma_offset_pcm_frames_const_ptr(p: pointer, offsetInFrames: uint64, format: ma_format, channels: uint32): pointer <cimport, nodecl> end
global function ma_offset_pcm_frames_ptr_f32(p: *float32, offsetInFrames: uint64, channels: uint32): *float32 <cimport, nodecl> end
global function ma_offset_pcm_frames_const_ptr_f32(p: *float32, offsetInFrames: uint64, channels: uint32): *float32 <cimport, nodecl> end
global function ma_clip_samples_f32(p: *float32, sampleCount: uint64) <cimport, nodecl> end
global function ma_clip_pcm_frames_f32(p: *float32, frameCount: uint64, channels: uint32) <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_u8(pSamplesOut: *uint8, pSamplesIn: *uint8, sampleCount: uint64, factor: float32) <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_s16(pSamplesOut: *int16, pSamplesIn: *int16, sampleCount: uint64, factor: float32) <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_s24(pSamplesOut: pointer, pSamplesIn: pointer, sampleCount: uint64, factor: float32) <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_s32(pSamplesOut: *int32, pSamplesIn: *int32, sampleCount: uint64, factor: float32) <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_f32(pSamplesOut: *float32, pSamplesIn: *float32, sampleCount: uint64, factor: float32) <cimport, nodecl> end
global function ma_apply_volume_factor_u8(pSamples: *uint8, sampleCount: uint64, factor: float32) <cimport, nodecl> end
global function ma_apply_volume_factor_s16(pSamples: *int16, sampleCount: uint64, factor: float32) <cimport, nodecl> end
global function ma_apply_volume_factor_s24(pSamples: pointer, sampleCount: uint64, factor: float32) <cimport, nodecl> end
global function ma_apply_volume_factor_s32(pSamples: *int32, sampleCount: uint64, factor: float32) <cimport, nodecl> end
global function ma_apply_volume_factor_f32(pSamples: *float32, sampleCount: uint64, factor: float32) <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_pcm_frames_u8(pPCMFramesOut: *uint8, pPCMFramesIn: *uint8, frameCount: uint64, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_pcm_frames_s16(pPCMFramesOut: *int16, pPCMFramesIn: *int16, frameCount: uint64, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_pcm_frames_s24(pPCMFramesOut: pointer, pPCMFramesIn: pointer, frameCount: uint64, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_pcm_frames_s32(pPCMFramesOut: *int32, pPCMFramesIn: *int32, frameCount: uint64, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_pcm_frames_f32(pPCMFramesOut: *float32, pPCMFramesIn: *float32, frameCount: uint64, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_copy_and_apply_volume_factor_pcm_frames(pFramesOut: pointer, pFramesIn: pointer, frameCount: uint64, format: ma_format, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_apply_volume_factor_pcm_frames_u8(pFrames: *uint8, frameCount: uint64, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_apply_volume_factor_pcm_frames_s16(pFrames: *int16, frameCount: uint64, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_apply_volume_factor_pcm_frames_s24(pFrames: pointer, frameCount: uint64, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_apply_volume_factor_pcm_frames_s32(pFrames: *int32, frameCount: uint64, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_apply_volume_factor_pcm_frames_f32(pFrames: *float32, frameCount: uint64, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_apply_volume_factor_pcm_frames(pFrames: pointer, frameCount: uint64, format: ma_format, channels: uint32, factor: float32) <cimport, nodecl> end
global function ma_factor_to_gain_db(factor: float32): float32 <cimport, nodecl> end
global function ma_gain_db_to_factor(gain: float32): float32 <cimport, nodecl> end
global ma_data_source_callbacks: type <cimport, nodecl> = @record{
  onRead: function(pointer, pointer, uint64, *uint64): ma_result,
  onSeek: function(pointer, uint64): ma_result,
  onMap: function(pointer, *pointer, *uint64): ma_result,
  onUnmap: function(pointer, uint64): ma_result,
  onGetDataFormat: function(pointer, *ma_format, *uint32, *uint32): ma_result,
  onGetCursor: function(pointer, *uint64): ma_result,
  onGetLength: function(pointer, *uint64): ma_result
}
global function ma_data_source_read_pcm_frames(pDataSource: pointer, pFramesOut: pointer, frameCount: uint64, pFramesRead: *uint64, loop: ma_bool32): ma_result <cimport, nodecl> end
global function ma_data_source_seek_pcm_frames(pDataSource: pointer, frameCount: uint64, pFramesSeeked: *uint64, loop: ma_bool32): ma_result <cimport, nodecl> end
global function ma_data_source_seek_to_pcm_frame(pDataSource: pointer, frameIndex: uint64): ma_result <cimport, nodecl> end
global function ma_data_source_map(pDataSource: pointer, ppFramesOut: *pointer, pFrameCount: *uint64): ma_result <cimport, nodecl> end
global function ma_data_source_unmap(pDataSource: pointer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_data_source_get_data_format(pDataSource: pointer, pFormat: *ma_format, pChannels: *uint32, pSampleRate: *uint32): ma_result <cimport, nodecl> end
global function ma_data_source_get_cursor_in_pcm_frames(pDataSource: pointer, pCursor: *uint64): ma_result <cimport, nodecl> end
global function ma_data_source_get_length_in_pcm_frames(pDataSource: pointer, pLength: *uint64): ma_result <cimport, nodecl> end
global ma_audio_buffer_ref: type <cimport, nodecl> = @record{
  ds: ma_data_source_callbacks,
  format: ma_format,
  channels: uint32,
  cursor: uint64,
  sizeInFrames: uint64,
  pData: pointer
}
global function ma_audio_buffer_ref_init(format: ma_format, channels: uint32, pData: pointer, sizeInFrames: uint64, pAudioBufferRef: *ma_audio_buffer_ref): ma_result <cimport, nodecl> end
global function ma_audio_buffer_ref_set_data(pAudioBufferRef: *ma_audio_buffer_ref, pData: pointer, sizeInFrames: uint64): ma_result <cimport, nodecl> end
global function ma_audio_buffer_ref_read_pcm_frames(pAudioBufferRef: *ma_audio_buffer_ref, pFramesOut: pointer, frameCount: uint64, loop: ma_bool32): uint64 <cimport, nodecl> end
global function ma_audio_buffer_ref_seek_to_pcm_frame(pAudioBufferRef: *ma_audio_buffer_ref, frameIndex: uint64): ma_result <cimport, nodecl> end
global function ma_audio_buffer_ref_map(pAudioBufferRef: *ma_audio_buffer_ref, ppFramesOut: *pointer, pFrameCount: *uint64): ma_result <cimport, nodecl> end
global function ma_audio_buffer_ref_unmap(pAudioBufferRef: *ma_audio_buffer_ref, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_audio_buffer_ref_at_end(pAudioBufferRef: *ma_audio_buffer_ref): ma_result <cimport, nodecl> end
global function ma_audio_buffer_ref_get_available_frames(pAudioBufferRef: *ma_audio_buffer_ref, pAvailableFrames: *uint64): ma_result <cimport, nodecl> end
global ma_audio_buffer_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sizeInFrames: uint64,
  pData: pointer,
  allocationCallbacks: ma_allocation_callbacks
}
global function ma_audio_buffer_config_init(format: ma_format, channels: uint32, sizeInFrames: uint64, pData: pointer, pAllocationCallbacks: *ma_allocation_callbacks): ma_audio_buffer_config <cimport, nodecl> end
global ma_audio_buffer: type <cimport, nodecl> = @record{
  ref: ma_audio_buffer_ref,
  allocationCallbacks: ma_allocation_callbacks,
  ownsData: ma_bool32,
  _pExtraData: [1]uint8
}
global function ma_audio_buffer_init(pConfig: *ma_audio_buffer_config, pAudioBuffer: *ma_audio_buffer): ma_result <cimport, nodecl> end
global function ma_audio_buffer_init_copy(pConfig: *ma_audio_buffer_config, pAudioBuffer: *ma_audio_buffer): ma_result <cimport, nodecl> end
global function ma_audio_buffer_alloc_and_init(pConfig: *ma_audio_buffer_config, ppAudioBuffer: **ma_audio_buffer): ma_result <cimport, nodecl> end
global function ma_audio_buffer_uninit(pAudioBuffer: *ma_audio_buffer) <cimport, nodecl> end
global function ma_audio_buffer_uninit_and_free(pAudioBuffer: *ma_audio_buffer) <cimport, nodecl> end
global function ma_audio_buffer_read_pcm_frames(pAudioBuffer: *ma_audio_buffer, pFramesOut: pointer, frameCount: uint64, loop: ma_bool32): uint64 <cimport, nodecl> end
global function ma_audio_buffer_seek_to_pcm_frame(pAudioBuffer: *ma_audio_buffer, frameIndex: uint64): ma_result <cimport, nodecl> end
global function ma_audio_buffer_map(pAudioBuffer: *ma_audio_buffer, ppFramesOut: *pointer, pFrameCount: *uint64): ma_result <cimport, nodecl> end
global function ma_audio_buffer_unmap(pAudioBuffer: *ma_audio_buffer, frameCount: uint64): ma_result <cimport, nodecl> end
global function ma_audio_buffer_at_end(pAudioBuffer: *ma_audio_buffer): ma_result <cimport, nodecl> end
global function ma_audio_buffer_get_available_frames(pAudioBuffer: *ma_audio_buffer, pAvailableFrames: *uint64): ma_result <cimport, nodecl> end
global ma_vfs_file: type = @pointer
global ma_seek_origin: type <cimport, nodecl, using> = @enum(cint){
  ma_seek_origin_start = 0,
  ma_seek_origin_current = 1,
  ma_seek_origin_end = 2
}
global ma_file_info: type <cimport, nodecl> = @record{
  sizeInBytes: uint64
}
global ma_vfs_callbacks: type <cimport, nodecl> = @record{
  onOpen: function(pointer, cstring, uint32, *ma_vfs_file): ma_result,
  onOpenW: function(pointer, *cint, uint32, *ma_vfs_file): ma_result,
  onClose: function(pointer, ma_vfs_file): ma_result,
  onRead: function(pointer, ma_vfs_file, pointer, csize, *csize): ma_result,
  onWrite: function(pointer, ma_vfs_file, pointer, csize, *csize): ma_result,
  onSeek: function(pointer, ma_vfs_file, int64, ma_seek_origin): ma_result,
  onTell: function(pointer, ma_vfs_file, *int64): ma_result,
  onInfo: function(pointer, ma_vfs_file, *ma_file_info): ma_result
}
global function ma_vfs_open(pVFS: pointer, pFilePath: cstring, openMode: uint32, pFile: *ma_vfs_file): ma_result <cimport, nodecl> end
global function ma_vfs_open_w(pVFS: pointer, pFilePath: *cint, openMode: uint32, pFile: *ma_vfs_file): ma_result <cimport, nodecl> end
global function ma_vfs_close(pVFS: pointer, file: ma_vfs_file): ma_result <cimport, nodecl> end
global function ma_vfs_read(pVFS: pointer, file: ma_vfs_file, pDst: pointer, sizeInBytes: csize, pBytesRead: *csize): ma_result <cimport, nodecl> end
global function ma_vfs_write(pVFS: pointer, file: ma_vfs_file, pSrc: pointer, sizeInBytes: csize, pBytesWritten: *csize): ma_result <cimport, nodecl> end
global function ma_vfs_seek(pVFS: pointer, file: ma_vfs_file, offset: int64, origin: ma_seek_origin): ma_result <cimport, nodecl> end
global function ma_vfs_tell(pVFS: pointer, file: ma_vfs_file, pCursor: *int64): ma_result <cimport, nodecl> end
global function ma_vfs_info(pVFS: pointer, file: ma_vfs_file, pInfo: *ma_file_info): ma_result <cimport, nodecl> end
global function ma_vfs_open_and_read_file(pVFS: pointer, pFilePath: cstring, ppData: *pointer, pSize: *csize, pAllocationCallbacks: *ma_allocation_callbacks): ma_result <cimport, nodecl> end
global ma_default_vfs: type <cimport, nodecl> = @record{
  cb: ma_vfs_callbacks,
  allocationCallbacks: ma_allocation_callbacks
}
global function ma_default_vfs_init(pVFS: *ma_default_vfs, pAllocationCallbacks: *ma_allocation_callbacks): ma_result <cimport, nodecl> end
global ma_resource_format: type <cimport, nodecl, using> = @enum(cint){
  ma_resource_format_wav = 0
}
global ma_decoder: type <cimport, nodecl, forwarddecl> = @record{}
global ma_decoder_read_proc: type <cimport, nodecl> = @function(*ma_decoder, pointer, csize): csize
global ma_decoder_seek_proc: type <cimport, nodecl> = @function(*ma_decoder, cint, ma_seek_origin): ma_bool32
global ma_decoder_read_pcm_frames_proc: type <cimport, nodecl> = @function(*ma_decoder, pointer, uint64): uint64
global ma_decoder_seek_to_pcm_frame_proc: type <cimport, nodecl> = @function(*ma_decoder, uint64): ma_result
global ma_decoder_uninit_proc: type <cimport, nodecl> = @function(*ma_decoder): ma_result
global ma_decoder_get_length_in_pcm_frames_proc: type <cimport, nodecl> = @function(*ma_decoder): uint64
global ma_decoder_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  channelMap: [32]cuchar,
  channelMixMode: ma_channel_mix_mode,
  ditherMode: ma_dither_mode,
  resampling: record{
    algorithm: ma_resample_algorithm,
    linear: record{
      lpfOrder: uint32
    },
    speex: record{
      quality: cint
    }
  },
  allocationCallbacks: ma_allocation_callbacks
}
ma_decoder = @record{
  ds: ma_data_source_callbacks,
  onRead: ma_decoder_read_proc,
  onSeek: ma_decoder_seek_proc,
  pUserData: pointer,
  readPointerInBytes: uint64,
  readPointerInPCMFrames: uint64,
  internalFormat: ma_format,
  internalChannels: uint32,
  internalSampleRate: uint32,
  internalChannelMap: [32]cuchar,
  outputFormat: ma_format,
  outputChannels: uint32,
  outputSampleRate: uint32,
  outputChannelMap: [32]cuchar,
  converter: ma_data_converter,
  allocationCallbacks: ma_allocation_callbacks,
  onReadPCMFrames: ma_decoder_read_pcm_frames_proc,
  onSeekToPCMFrame: ma_decoder_seek_to_pcm_frame_proc,
  onUninit: ma_decoder_uninit_proc,
  onGetLengthInPCMFrames: ma_decoder_get_length_in_pcm_frames_proc,
  pInternalDecoder: pointer,
  backend: union{
    vfs: record{
      pVFS: pointer,
      file: ma_vfs_file
    },
    memory: record{
      pData: *uint8,
      dataSize: csize,
      currentReadPos: csize
    }
  }
}
global function ma_decoder_config_init(outputFormat: ma_format, outputChannels: uint32, outputSampleRate: uint32): ma_decoder_config <cimport, nodecl> end
global function ma_decoder_init(onRead: ma_decoder_read_proc, onSeek: ma_decoder_seek_proc, pUserData: pointer, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_wav(onRead: ma_decoder_read_proc, onSeek: ma_decoder_seek_proc, pUserData: pointer, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_flac(onRead: ma_decoder_read_proc, onSeek: ma_decoder_seek_proc, pUserData: pointer, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_mp3(onRead: ma_decoder_read_proc, onSeek: ma_decoder_seek_proc, pUserData: pointer, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_vorbis(onRead: ma_decoder_read_proc, onSeek: ma_decoder_seek_proc, pUserData: pointer, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_raw(onRead: ma_decoder_read_proc, onSeek: ma_decoder_seek_proc, pUserData: pointer, pConfigIn: *ma_decoder_config, pConfigOut: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_memory(pData: pointer, dataSize: csize, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_memory_wav(pData: pointer, dataSize: csize, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_memory_flac(pData: pointer, dataSize: csize, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_memory_mp3(pData: pointer, dataSize: csize, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_memory_vorbis(pData: pointer, dataSize: csize, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_memory_raw(pData: pointer, dataSize: csize, pConfigIn: *ma_decoder_config, pConfigOut: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_vfs(pVFS: pointer, pFilePath: cstring, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_vfs_wav(pVFS: pointer, pFilePath: cstring, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_vfs_flac(pVFS: pointer, pFilePath: cstring, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_vfs_mp3(pVFS: pointer, pFilePath: cstring, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_vfs_vorbis(pVFS: pointer, pFilePath: cstring, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_vfs_w(pVFS: pointer, pFilePath: *cint, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_vfs_wav_w(pVFS: pointer, pFilePath: *cint, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_vfs_flac_w(pVFS: pointer, pFilePath: *cint, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_vfs_mp3_w(pVFS: pointer, pFilePath: *cint, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_vfs_vorbis_w(pVFS: pointer, pFilePath: *cint, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_file(pFilePath: cstring, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_file_wav(pFilePath: cstring, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_file_flac(pFilePath: cstring, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_file_mp3(pFilePath: cstring, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_file_vorbis(pFilePath: cstring, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_file_w(pFilePath: *cint, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_file_wav_w(pFilePath: *cint, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_file_flac_w(pFilePath: *cint, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_file_mp3_w(pFilePath: *cint, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_init_file_vorbis_w(pFilePath: *cint, pConfig: *ma_decoder_config, pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_uninit(pDecoder: *ma_decoder): ma_result <cimport, nodecl> end
global function ma_decoder_get_cursor_in_pcm_frames(pDecoder: *ma_decoder, pCursor: *uint64): ma_result <cimport, nodecl> end
global function ma_decoder_get_length_in_pcm_frames(pDecoder: *ma_decoder): uint64 <cimport, nodecl> end
global function ma_decoder_read_pcm_frames(pDecoder: *ma_decoder, pFramesOut: pointer, frameCount: uint64): uint64 <cimport, nodecl> end
global function ma_decoder_seek_to_pcm_frame(pDecoder: *ma_decoder, frameIndex: uint64): ma_result <cimport, nodecl> end
global function ma_decoder_get_available_frames(pDecoder: *ma_decoder, pAvailableFrames: *uint64): ma_result <cimport, nodecl> end
global function ma_decode_from_vfs(pVFS: pointer, pFilePath: cstring, pConfig: *ma_decoder_config, pFrameCountOut: *uint64, ppPCMFramesOut: *pointer): ma_result <cimport, nodecl> end
global function ma_decode_file(pFilePath: cstring, pConfig: *ma_decoder_config, pFrameCountOut: *uint64, ppPCMFramesOut: *pointer): ma_result <cimport, nodecl> end
global function ma_decode_memory(pData: pointer, dataSize: csize, pConfig: *ma_decoder_config, pFrameCountOut: *uint64, ppPCMFramesOut: *pointer): ma_result <cimport, nodecl> end
global ma_encoder: type <cimport, nodecl, forwarddecl> = @record{}
global ma_encoder_write_proc: type <cimport, nodecl> = @function(*ma_encoder, pointer, csize): csize
global ma_encoder_seek_proc: type <cimport, nodecl> = @function(*ma_encoder, cint, ma_seek_origin): ma_bool32
global ma_encoder_init_proc: type <cimport, nodecl> = @function(*ma_encoder): ma_result
global ma_encoder_uninit_proc: type <cimport, nodecl> = @function(*ma_encoder)
global ma_encoder_write_pcm_frames_proc: type <cimport, nodecl> = @function(*ma_encoder, pointer, uint64): uint64
global ma_encoder_config: type <cimport, nodecl> = @record{
  resourceFormat: ma_resource_format,
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  allocationCallbacks: ma_allocation_callbacks
}
global function ma_encoder_config_init(resourceFormat: ma_resource_format, format: ma_format, channels: uint32, sampleRate: uint32): ma_encoder_config <cimport, nodecl> end
ma_encoder = @record{
  config: ma_encoder_config,
  onWrite: ma_encoder_write_proc,
  onSeek: ma_encoder_seek_proc,
  onInit: ma_encoder_init_proc,
  onUninit: ma_encoder_uninit_proc,
  onWritePCMFrames: ma_encoder_write_pcm_frames_proc,
  pUserData: pointer,
  pInternalEncoder: pointer,
  pFile: pointer
}
global function ma_encoder_init(onWrite: ma_encoder_write_proc, onSeek: ma_encoder_seek_proc, pUserData: pointer, pConfig: *ma_encoder_config, pEncoder: *ma_encoder): ma_result <cimport, nodecl> end
global function ma_encoder_init_file(pFilePath: cstring, pConfig: *ma_encoder_config, pEncoder: *ma_encoder): ma_result <cimport, nodecl> end
global function ma_encoder_init_file_w(pFilePath: *cint, pConfig: *ma_encoder_config, pEncoder: *ma_encoder): ma_result <cimport, nodecl> end
global function ma_encoder_uninit(pEncoder: *ma_encoder) <cimport, nodecl> end
global function ma_encoder_write_pcm_frames(pEncoder: *ma_encoder, pFramesIn: pointer, frameCount: uint64): uint64 <cimport, nodecl> end
global ma_waveform_type: type <cimport, nodecl, using> = @enum(cint){
  ma_waveform_type_sine = 0,
  ma_waveform_type_square = 1,
  ma_waveform_type_triangle = 2,
  ma_waveform_type_sawtooth = 3
}
global ma_waveform_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  sampleRate: uint32,
  type: ma_waveform_type,
  amplitude: float64,
  frequency: float64
}
global function ma_waveform_config_init(format: ma_format, channels: uint32, sampleRate: uint32, type: ma_waveform_type, amplitude: float64, frequency: float64): ma_waveform_config <cimport, nodecl> end
global ma_waveform: type <cimport, nodecl> = @record{
  ds: ma_data_source_callbacks,
  config: ma_waveform_config,
  advance: float64,
  time: float64
}
global function ma_waveform_init(pConfig: *ma_waveform_config, pWaveform: *ma_waveform): ma_result <cimport, nodecl> end
global function ma_waveform_read_pcm_frames(pWaveform: *ma_waveform, pFramesOut: pointer, frameCount: uint64): uint64 <cimport, nodecl> end
global function ma_waveform_seek_to_pcm_frame(pWaveform: *ma_waveform, frameIndex: uint64): ma_result <cimport, nodecl> end
global function ma_waveform_set_amplitude(pWaveform: *ma_waveform, amplitude: float64): ma_result <cimport, nodecl> end
global function ma_waveform_set_frequency(pWaveform: *ma_waveform, frequency: float64): ma_result <cimport, nodecl> end
global function ma_waveform_set_type(pWaveform: *ma_waveform, type: ma_waveform_type): ma_result <cimport, nodecl> end
global function ma_waveform_set_sample_rate(pWaveform: *ma_waveform, sampleRate: uint32): ma_result <cimport, nodecl> end
global ma_noise_type: type <cimport, nodecl, using> = @enum(cint){
  ma_noise_type_white = 0,
  ma_noise_type_pink = 1,
  ma_noise_type_brownian = 2
}
global ma_noise_config: type <cimport, nodecl> = @record{
  format: ma_format,
  channels: uint32,
  type: ma_noise_type,
  seed: int32,
  amplitude: float64,
  duplicateChannels: ma_bool32
}
global function ma_noise_config_init(format: ma_format, channels: uint32, type: ma_noise_type, seed: int32, amplitude: float64): ma_noise_config <cimport, nodecl> end
global ma_noise: type <cimport, nodecl> = @record{
  ds: ma_data_source_callbacks,
  config: ma_noise_config,
  lcg: ma_lcg,
  state: union{
    pink: record{
      bin: [32][16]float64,
      accumulation: [32]float64,
      counter: [32]uint32
    },
    brownian: record{
      accumulation: [32]float64
    }
  }
}
global function ma_noise_init(pConfig: *ma_noise_config, pNoise: *ma_noise): ma_result <cimport, nodecl> end
global function ma_noise_read_pcm_frames(pNoise: *ma_noise, pFramesOut: pointer, frameCount: uint64): uint64 <cimport, nodecl> end
global function ma_noise_set_amplitude(pNoise: *ma_noise, amplitude: float64): ma_result <cimport, nodecl> end
global function ma_noise_set_seed(pNoise: *ma_noise, seed: int32): ma_result <cimport, nodecl> end
global function ma_noise_set_type(pNoise: *ma_noise, type: ma_noise_type): ma_result <cimport, nodecl> end
global MA_VERSION_MAJOR: cint <cimport, nodecl, const>
global MA_VERSION_MINOR: cint <cimport, nodecl, const>
global MA_VERSION_REVISION: cint <cimport, nodecl, const>
global MA_VERSION_STRING: cstring <cimport, nodecl, const>
global MA_TRUE: cint <comptime> = 1
global MA_FALSE: cint <comptime> = 0
global MA_LOG_LEVEL_VERBOSE: cint <comptime> = 4
global MA_LOG_LEVEL_INFO: cint <comptime> = 3
global MA_LOG_LEVEL_WARNING: cint <comptime> = 2
global MA_LOG_LEVEL_ERROR: cint <comptime> = 1
global MA_LOG_LEVEL: cint <cimport, nodecl, const>
global MA_CHANNEL_NONE: cint <comptime> = 0
global MA_CHANNEL_MONO: cint <comptime> = 1
global MA_CHANNEL_FRONT_LEFT: cint <comptime> = 2
global MA_CHANNEL_FRONT_RIGHT: cint <comptime> = 3
global MA_CHANNEL_FRONT_CENTER: cint <comptime> = 4
global MA_CHANNEL_LFE: cint <comptime> = 5
global MA_CHANNEL_BACK_LEFT: cint <comptime> = 6
global MA_CHANNEL_BACK_RIGHT: cint <comptime> = 7
global MA_CHANNEL_FRONT_LEFT_CENTER: cint <comptime> = 8
global MA_CHANNEL_FRONT_RIGHT_CENTER: cint <comptime> = 9
global MA_CHANNEL_BACK_CENTER: cint <comptime> = 10
global MA_CHANNEL_SIDE_LEFT: cint <comptime> = 11
global MA_CHANNEL_SIDE_RIGHT: cint <comptime> = 12
global MA_CHANNEL_TOP_CENTER: cint <comptime> = 13
global MA_CHANNEL_TOP_FRONT_LEFT: cint <comptime> = 14
global MA_CHANNEL_TOP_FRONT_CENTER: cint <comptime> = 15
global MA_CHANNEL_TOP_FRONT_RIGHT: cint <comptime> = 16
global MA_CHANNEL_TOP_BACK_LEFT: cint <comptime> = 17
global MA_CHANNEL_TOP_BACK_CENTER: cint <comptime> = 18
global MA_CHANNEL_TOP_BACK_RIGHT: cint <comptime> = 19
global MA_CHANNEL_AUX_0: cint <comptime> = 20
global MA_CHANNEL_AUX_1: cint <comptime> = 21
global MA_CHANNEL_AUX_2: cint <comptime> = 22
global MA_CHANNEL_AUX_3: cint <comptime> = 23
global MA_CHANNEL_AUX_4: cint <comptime> = 24
global MA_CHANNEL_AUX_5: cint <comptime> = 25
global MA_CHANNEL_AUX_6: cint <comptime> = 26
global MA_CHANNEL_AUX_7: cint <comptime> = 27
global MA_CHANNEL_AUX_8: cint <comptime> = 28
global MA_CHANNEL_AUX_9: cint <comptime> = 29
global MA_CHANNEL_AUX_10: cint <comptime> = 30
global MA_CHANNEL_AUX_11: cint <comptime> = 31
global MA_CHANNEL_AUX_12: cint <comptime> = 32
global MA_CHANNEL_AUX_13: cint <comptime> = 33
global MA_CHANNEL_AUX_14: cint <comptime> = 34
global MA_CHANNEL_AUX_15: cint <comptime> = 35
global MA_CHANNEL_AUX_16: cint <comptime> = 36
global MA_CHANNEL_AUX_17: cint <comptime> = 37
global MA_CHANNEL_AUX_18: cint <comptime> = 38
global MA_CHANNEL_AUX_19: cint <comptime> = 39
global MA_CHANNEL_AUX_20: cint <comptime> = 40
global MA_CHANNEL_AUX_21: cint <comptime> = 41
global MA_CHANNEL_AUX_22: cint <comptime> = 42
global MA_CHANNEL_AUX_23: cint <comptime> = 43
global MA_CHANNEL_AUX_24: cint <comptime> = 44
global MA_CHANNEL_AUX_25: cint <comptime> = 45
global MA_CHANNEL_AUX_26: cint <comptime> = 46
global MA_CHANNEL_AUX_27: cint <comptime> = 47
global MA_CHANNEL_AUX_28: cint <comptime> = 48
global MA_CHANNEL_AUX_29: cint <comptime> = 49
global MA_CHANNEL_AUX_30: cint <comptime> = 50
global MA_CHANNEL_AUX_31: cint <comptime> = 51
global MA_CHANNEL_LEFT: cint <cimport, nodecl, const>
global MA_CHANNEL_RIGHT: cint <cimport, nodecl, const>
global MA_CHANNEL_POSITION_COUNT: cint <cimport, nodecl, const>
global MA_SUCCESS: cint <comptime> = 0
global MA_ERROR: cint <comptime> = -1
global MA_INVALID_ARGS: cint <comptime> = -2
global MA_INVALID_OPERATION: cint <comptime> = -3
global MA_OUT_OF_MEMORY: cint <comptime> = -4
global MA_OUT_OF_RANGE: cint <comptime> = -5
global MA_ACCESS_DENIED: cint <comptime> = -6
global MA_DOES_NOT_EXIST: cint <comptime> = -7
global MA_ALREADY_EXISTS: cint <comptime> = -8
global MA_TOO_MANY_OPEN_FILES: cint <comptime> = -9
global MA_INVALID_FILE: cint <comptime> = -10
global MA_TOO_BIG: cint <comptime> = -11
global MA_PATH_TOO_LONG: cint <comptime> = -12
global MA_NAME_TOO_LONG: cint <comptime> = -13
global MA_NOT_DIRECTORY: cint <comptime> = -14
global MA_IS_DIRECTORY: cint <comptime> = -15
global MA_DIRECTORY_NOT_EMPTY: cint <comptime> = -16
global MA_END_OF_FILE: cint <comptime> = -17
global MA_NO_SPACE: cint <comptime> = -18
global MA_BUSY: cint <comptime> = -19
global MA_IO_ERROR: cint <comptime> = -20
global MA_INTERRUPT: cint <comptime> = -21
global MA_UNAVAILABLE: cint <comptime> = -22
global MA_ALREADY_IN_USE: cint <comptime> = -23
global MA_BAD_ADDRESS: cint <comptime> = -24
global MA_BAD_SEEK: cint <comptime> = -25
global MA_BAD_PIPE: cint <comptime> = -26
global MA_DEADLOCK: cint <comptime> = -27
global MA_TOO_MANY_LINKS: cint <comptime> = -28
global MA_NOT_IMPLEMENTED: cint <comptime> = -29
global MA_NO_MESSAGE: cint <comptime> = -30
global MA_BAD_MESSAGE: cint <comptime> = -31
global MA_NO_DATA_AVAILABLE: cint <comptime> = -32
global MA_INVALID_DATA: cint <comptime> = -33
global MA_TIMEOUT: cint <comptime> = -34
global MA_NO_NETWORK: cint <comptime> = -35
global MA_NOT_UNIQUE: cint <comptime> = -36
global MA_NOT_SOCKET: cint <comptime> = -37
global MA_NO_ADDRESS: cint <comptime> = -38
global MA_BAD_PROTOCOL: cint <comptime> = -39
global MA_PROTOCOL_UNAVAILABLE: cint <comptime> = -40
global MA_PROTOCOL_NOT_SUPPORTED: cint <comptime> = -41
global MA_PROTOCOL_FAMILY_NOT_SUPPORTED: cint <comptime> = -42
global MA_ADDRESS_FAMILY_NOT_SUPPORTED: cint <comptime> = -43
global MA_SOCKET_NOT_SUPPORTED: cint <comptime> = -44
global MA_CONNECTION_RESET: cint <comptime> = -45
global MA_ALREADY_CONNECTED: cint <comptime> = -46
global MA_NOT_CONNECTED: cint <comptime> = -47
global MA_CONNECTION_REFUSED: cint <comptime> = -48
global MA_NO_HOST: cint <comptime> = -49
global MA_IN_PROGRESS: cint <comptime> = -50
global MA_CANCELLED: cint <comptime> = -51
global MA_MEMORY_ALREADY_MAPPED: cint <comptime> = -52
global MA_AT_END: cint <comptime> = -53
global MA_FORMAT_NOT_SUPPORTED: cint <comptime> = -100
global MA_DEVICE_TYPE_NOT_SUPPORTED: cint <comptime> = -101
global MA_SHARE_MODE_NOT_SUPPORTED: cint <comptime> = -102
global MA_NO_BACKEND: cint <comptime> = -103
global MA_NO_DEVICE: cint <comptime> = -104
global MA_API_NOT_FOUND: cint <comptime> = -105
global MA_INVALID_DEVICE_CONFIG: cint <comptime> = -106
global MA_LOOP: cint <comptime> = -107
global MA_DEVICE_NOT_INITIALIZED: cint <comptime> = -200
global MA_DEVICE_ALREADY_INITIALIZED: cint <comptime> = -201
global MA_DEVICE_NOT_STARTED: cint <comptime> = -202
global MA_DEVICE_NOT_STOPPED: cint <comptime> = -203
global MA_FAILED_TO_INIT_BACKEND: cint <comptime> = -300
global MA_FAILED_TO_OPEN_BACKEND_DEVICE: cint <comptime> = -301
global MA_FAILED_TO_START_BACKEND_DEVICE: cint <comptime> = -302
global MA_FAILED_TO_STOP_BACKEND_DEVICE: cint <comptime> = -303
global MA_MIN_CHANNELS: cint <comptime> = 1
global MA_MAX_CHANNELS: cint <comptime> = 32
global MA_MAX_FILTER_ORDER: cint <comptime> = 8
global MA_MIN_SAMPLE_RATE: cint <cimport, nodecl, const>
global MA_MAX_SAMPLE_RATE: cint <cimport, nodecl, const>
global MA_STATE_UNINITIALIZED: cint <comptime> = 0
global MA_STATE_STOPPED: cint <comptime> = 1
global MA_STATE_STARTED: cint <comptime> = 2
global MA_STATE_STARTING: cint <comptime> = 3
global MA_STATE_STOPPING: cint <comptime> = 4
global MA_BACKEND_COUNT: cint <cimport, nodecl, const>
global MA_DATA_FORMAT_FLAG_EXCLUSIVE_MODE: cint <cimport, nodecl, const>
global MA_OPEN_MODE_READ: cint <comptime> = 0x00000001
global MA_OPEN_MODE_WRITE: cint <comptime> = 0x00000002
